---
title: Реляційні бази даних
parent: Бази даних
nav_order: 2
layout: default
---

<!-- @formatter:off -->
# Реляційні бази даних
- TOC
{:toc}
<!-- @formatter:on -->

### Що таке реляційна база даних?

<hr>

**Реляційна база даних (RDBMS, Relational DataBase Management System)** — це система для зберігання
та керування даними, в якій інформація організована у вигляді **таблиць** (relations).

Таблиця складається зі **стовпців** (columns, attributes) та рядків (rows, tuples).
Кожен **рядок** — це один запис (наприклад, один клієнт, одне замовлення).

Стовпці визначають властивості/поля (наприклад: ім’я, дата народження, сума замовлення).
**Ключі** (primary key, foreign key) визначають унікальність і зв’язки між таблицями.

### Які бувають ключі в базах даних?

<hr>

У базах даних ключі використовуються для унікальної ідентифікації записів та встановлення зв’язків
між таблицями.

1. **Первинний ключ (Primary Key)** унікально ідентифікує кожен рядок у таблиці. Значення
   первинного ключа в межах таблиці не може повторюватися і не може бути NULL.

2. **Зовнішній ключ (Foreign Key)** встановлює зв’язок між двома таблицями. Зовнішній ключ
   посилається на первинний ключ іншої таблиці та забезпечує цілісність даних.

3. **Альтернативний ключ (Alternate Key)** — будь-яке унікальне поле, яке могло б стати первинним
   ключем, але ним не є.

4. **Сурогатний ключ (Surrogate Key)** — штучно створене унікальне поле для ідентифікації записів.

5. **Складений ключ (Composite Key)** — складається з двох або більше полів для унікальної
   ідентифікації запису.

6. **Суперключ (Superkey)** — це будь-яка комбінація стовпців у таблиці, яка дозволяє унікально
   ідентифікувати кожен запис.

7. **Кандидатний ключ (Candidate Key)** — це мінімальний суперключ, тобто суперключ без зайвих
   атрибутів.

### Первинний ключ

<hr>

**Первинний ключ (Primary Key)** — це стовпець або комбінація стовпців у таблиці бази даних, які
унікально ідентифікують кожен запис.

Основні характеристики:

* Унікальність – значення первинного ключа не повторюється в таблиці.
* Не допускає NULL – кожен запис обов’язково має мати значення первинного ключа.
* Стабільність – значення первинного ключа рідко змінюється, оскільки воно визначає ідентичність
  запису.

### Зовнішній ключ

<hr>

**Зовнішній ключ (Foreign Key)** — це стовпець або комбінація стовпців у таблиці бази даних, які
посилаються на первинний ключ іншої таблиці. Він використовується для встановлення та підтримки
зв’язків між таблицями і забезпечує цілісність даних.

Основні характеристики:

* Посилання на первинний ключ іншої таблиці – зовнішній ключ повинен збігатися з існуючим значенням
  первинного ключа або бути NULL (якщо дозволено).
* Контроль цілісності – база даних не дозволить додати значення, яке не існує в головній таблиці.
* Зв’язки “один до багатьох” або “багато до багатьох” – найчастіше використовується для організації
  таких відношень.

Зовнішній ключ не обов'язково має посилатися саме на первинний ключ. Він може вказувати на
будь-який стовпець (або комбінацію стовпців) іншої таблиці, значення якого є унікальними. Звичайно,
найчастіше посилаються на первинний ключ, бо він завжди унікальний і не допускає NULL, але це не
обов’язкова умова.

### Що таке обмеження цілісності даних?

<hr>

**Обмеження цілісності даних (Data Integrity Constraints)** — це правила, які визначають, які
значення
можуть зберігатися в базі даних, щоб забезпечити її правильність і достовірність.

Основні типи обмежень:

* **PRIMARY KEY (Первинний ключ)** гарантує унікальність кожного запису та забороняє NULL.
* **FOREIGN KEY (Зовнішній ключ)** забезпечує зв’язок між таблицями і не дозволяє «висячі»
  посилання.
* **UNIQUE (Унікальність)** забезпечує унікальність значень у колонці або наборі колонок.
* **NOT NULL** забороняє порожні значення у стовпці.
* **CHECK** дозволяє задати логічну умову, яку повинні виконувати значення.
  Приклад: `CHECK (age >= 18)` – вік користувача не менше 18 років.
* **DEFAULT** автоматично встановлює значення за замовчуванням, якщо користувач його не вказав.

### Типи зв'язків між таблицями

<hr>

1. **Один до одного (one-to-one)**: кожен запис у таблиці А відповідає одному запису в таблиці B.
   Використовується рідко, зазвичай для розділення великої таблиці або з міркувань безпеки.

2. **Один до багатьох (one-to-many)**: кожен запис у таблиці А може відповідати багатьом записам у
   таблиці B, а кожен запис у B належить лише одному запису у A. Найпоширеніший тип зв’язку.

3. **Багато до багатьох (many-to-many)**: кожен запис у таблиці А може відповідати багатьом
   записам у таблиці B, і навпаки. Реалізується через додаткову проміжну таблицю ( junction
   table, bridge table, linking table).

### Що таке аномалії даних?

<hr>

**Аномалії даних (Data Anomalies)** — це непередбачувані або некоректні ситуації при додаванні,
зміні чи видаленні даних у базі даних, які порушують цілісність даних. Аномалії зазвичай виникають у
ненормалізованих таблицях, де дані дублюються або неструктуровані.

Основні типи аномалій:

* **Аномалія вставки (Insertion Anomaly)** виникає, коли неможливо додати новий запис без заповнення
  деяких інших даних. Приклад: у таблиці Студенти + Курси неможливо додати нового студента, якщо
  він ще не записався на жоден курс.

* **Аномалія оновлення (Update Anomaly)** виникає, коли зміна одного значення потребує
  багаторазового редагування в різних рядках. Приклад: якщо адреса викладача зберігається в
  кожному курсі, її зміну доведеться робити у всіх записах, інакше дані будуть суперечливими.

* **Аномалія видалення (Deletion Anomaly)** виникає, коли видалення одного запису призводить до
  втрати важливої інформації. Приклад: якщо студент закінчив останній курс і його запис
  видаляють, можна втратити інформацію про самого студента.

Як уникнути аномалій:

* Використовувати нормалізацію бази даних.
* Розділяти дані на таблиці відповідно до логічних сутностей.
* Використовувати ключі для зв’язків між таблицями (PRIMARY KEY, FOREIGN KEY).

### Що таке нормалізація?

<hr>

**Нормалізація бази даних** — це процес організації даних у таблицях таким чином, щоб зменшити
дублювання та уникнути аномалій даних.

Навіщо потрібна нормалізація:

* Уникнення аномалій даних
* Зменшення дублювання даних
    * Дані зберігаються лише один раз, економлячи місце та підвищуючи ефективність.
* Полегшення підтримки бази
* Підтримка цілісності даних

### Перша нормальна форма

<hr>

**Перша нормальна форма (1NF, First Normal Form)** — це правило нормалізації, яке
вимагає, щоб усі рядки були унікальними, а атрибути — атомарними, тобто кожне поле містило одне
значення, а не список чи множину значень.

Основні вимоги 1NF:

* Кожен стовпець містить тільки одне значення.
* Всі рядки таблиці унікальні (часто завдяки первинному ключу).
* Однорідність даних у стовпця (тип даних один для всіх записів).

Приклад порушення 1NF: поле `courses` містить декілька значень в одній клітинці → порушення 1NF.

| student_id | student_name | courses            |
|------------|--------------|--------------------|
| 1          | Петро        | Математика, Фізика |
| 2          | Марія        | Математика         |

Таблиця в 1NF: кожне поле містить лише одне значення.

| student_id | student_name | course       |
|------------|--------------|--------------|
| 1          | Петро        | Математика   |
| 1          | Петро        | Фізика       |
| 2          | Марія        | Математика   |

### Друга нормальна форма

<hr>

**Друга нормальна форма (2NF, Second Normal Form)** — це правило організації таблиці бази даних, яке
будується на основі 1NF і додатково вимагає, щоб кожен неключовий атрибут залежав від усього
первинного ключа, а не від його частини.

Основні вимоги 2NF:

* Таблиця повинна бути вже в 1NF.
* Якщо первинний ключ складається з кількох стовпців (складений ключ), жоден неключовий атрибут не
  повинен залежати лише від частини ключа. Це усуває часткові залежності, які призводять до
  дублювання даних.

Приклад порушення 2NF: таблиця записів студентів на курси (1NF) з складеним ключем (student_id +
course_id):

| student_id | student_name | course_id | course_name |
|------------|--------------|-----------|-------------|
| 1          | Петро        | 101       | Математика  |
| 1          | Петро        | 102       | Фізика      |
| 2          | Марія        | 101       | Математика  |

* Проблема: student_name залежить лише від student_id → часткова залежність.
* Також course_name залежить лише від course_id → часткова залежність.

Таблиці у 2NF

* Таблиця Студенти

  | student_id | student_name |
                          |------------|--------------|
  | 1          | Петро        |
  | 2          | Марія        |

* Таблиця Курси

  | course_id | course_name |
                          |-----------|-------------|
  | 101       | Математика  |
  | 102       | Фізика      |

* Таблиця ЗаписиКурсів

  | student_id | course_id |
                          |------------|-----------|
  | 1          | 101       |
  | 1          | 102       |
  | 2          | 101       |

Всі неключові атрибути тепер залежать від повного первинного ключа таблиці ЗаписиКурсів.

Дублювання і часткові залежності усунуті.

### Третя нормальна форма

<hr>

**Третя нормальна форма (3NF, Third Normal Form)** — це правило організації таблиці бази даних, яке
будується на основі 2NF і додатково вимагає, щоб кожен неключовий атрибут залежав тільки від
первинного ключа, а не від інших неключових атрибутів.

Основні вимоги 3NF:

* Таблиця вже повинна бути в 2NF.
* Таблиця не має транзитивних залежностей (коли один неключовий атрибут залежить від іншого
  неключового атрибута). Це допомагає усунути дублювання даних і полегшити підтримку бази.

Приклад порушення 3NF: таблиця студентів та курсів у 2NF

| student_id | student_name | course_id | course_name | instructor |
|------------|--------------|-----------|-------------|-----------|
| 1          | Петро        | 101       | Математика  | Іванов    |
| 1          | Петро        | 102       | Фізика      | Петров    |
| 2          | Марія        | 101       | Математика  | Іванов    |

Проблема: instructor залежить від course_name, а не напряму від первинного ключа (student_id +
course_id) → транзитивна залежність.

Таблиці у 3NF

* Таблиця Студенти

  | student_id | student_name |
                        |------------|--------------|
  | 1          | Петро        |
  | 2          | Марія        |

* Таблиця Курси

  | course_id | course_name | instructor |
                        |-----------|-------------|-----------|
  | 101       | Математика  | Іванов    |
  | 102       | Фізика      | Петров    |

* Таблиця ЗаписиКурсів

  | student_id | course_id |
                        |------------|-----------|
  | 1          | 101       |
  | 1          | 102       |
  | 2          | 101       |

Транзитивні залежності усунуті. Кожен неключовий атрибут залежить тільки від первинного ключа
своєї таблиці.

### Нормальна форма Бойса-Кодда

<hr>

BCNF (Boyce-Codd Normal Form) — це розширена версія 3NF, яка усуває більш складні аномалії, що
можуть залишитися навіть у таблицях у 3NF.

Основне правило BCNF:

* Таблиця повинна бути в 3NF.
* Для кожної функціональної залежності X → Y X повинен бути суперключем таблиці. Інакше кажуть:
  "ліва частина будь-якої функціональної залежності має бути суперключем".

Навіщо потрібна BCNF:

* У деяких таблицях у 3NF можуть залишатися аномалії через складні залежності між ключами.
* BCNF усуває ці випадки, роблячи структуру бази ще більш стабільною.

Приклад порушення BCNF: Таблиця з факультетами та курсами:

| course_id | instructor | faculty |
|-----------|-----------|--------|
| 101       | Іванов    | Математика |
| 102       | Петров    | Фізика     |

* Припустимо, один курс викладає тільки один викладач, але викладач може викладати кілька курсів у
  різних факультетах.
* Функціональна залежність instructor → faculty порушує BCNF, бо instructor не є суперключем, хоча
  визначає faculty.

Виправлення (розбиття таблиці на BCNF)

* Таблиця Курси

| course_id | instructor |
|-----------|------------|
| 101       | Іванов     |
| 102       | Петров     |

* Таблиця Викладачі

| instructor | faculty    |
|-----------|------------|
| Іванов    | Математика |
| Петров    | Фізика     |

Тепер кожна залежність має ліву частину як суперключ → BCNF досягнута.

### Що таке денормалізація?

<hr>

**Денормалізація** — це навмисне об’єднання або дублювання даних у базі даних, щоб підвищити
продуктивність запитів, навіть якщо це порушує нормальні форми. Іншими словами, це протилежний
процес нормалізації: замість поділу таблиць на менші для усунення
дублювання, деякі таблиці об’єднують, щоб зменшити кількість JOIN-запитів.

Навіщо потрібна денормалізація:

* Покращення швидкості запитів. Менше об’єднань (JOIN) → швидше виконання аналітичних запитів,
  особливо в OLAP-системах.
* Зменшення складності запитів. Дані вже в одній таблиці, не потрібно писати складні з’єднання.
* Оптимізація для звітності та аналітики. Зручно, коли часто потрібні агреговані або сумарні дані.