---
title: Протоколи
parent: Python
nav_order: 6
layout: default
---

<!-- @formatter:off -->
# Протоколи
- TOC
{:toc}
<!-- @formatter:on -->

## Загальне

### Що таке протокол у Python?

<hr>

**Протокол (protocol)** — це набір методів та атрибутів, які об’єкт повинен реалізувати, щоб
відповідати деякому інтерфейсу. Тобто протокол визначає «контракт» поведінки об’єкта без
формального наслідування через класи.

### Що таке subtyping у Python?

<hr>

**Успадкування типу (subtyping)** — це принцип об’єктно-орієнтованого програмування, який означає,
що один тип (клас) може бути розглянутий як підтип іншого типу (класу), тобто об’єкти підтипу
можуть використовуватися там, де очікується базовий тип.

У Python subtyping має два основні різновиди: номінальне і структурне.

**Nominal subtyping**: підтип визначається через явне успадкування класів.

<!-- @formatter:off -->
```python
class Animal:
    pass

class Dog(Animal):  # Dog — підтип Animal
    pass

a: Animal = Dog()  # коректно
```
<!-- @formatter:on -->

Тут `Dog` є підтипом `Animal`, бо явно успадковує його.

**Structural subtyping**: підтип визначається не ім’ям класу, а наявністю потрібних методів або
атрибутів. Використовується _duck typing_ і протоколи (`Protocol`) з модуля `typing`.

<!-- @formatter:off -->
```python
from typing import Protocol

class Quackable(Protocol):
    def quack(self) -> None:
        ...

class Duck:
    def quack(self) -> None:
        print("Quack!")

def make_it_quack(q: Quackable):
    q.quack()

make_it_quack(Duck())  # Duck реалізує протокол → працює
```
<!-- @formatter:off -->

Тут `Duck` не успадковує `Quackable`, але все одно сумісний із його «структурою» → структурний
підтип.

## Iterators та Iterables

### Що таке `Iterable` у Python?

<hr>

**Iterable** — це об’єкт, що містить елементи, які можна перебрати в циклі `for` або отримати через
функцію `iter()`. Списки, кортежі, словники та множини є _iterable_. Ключові особливості:

* Має метод `__iter__()`, який повертає ітератор.
* Може бути переданий у будь-яку конструкцію, що перебирає елементи (`for`, `list()`, `tuple()`,
  `sum()` тощо).
* Iterable можна використовувати багато разів для створення нових iterator-ів.

<!-- @formatter:off -->
```python
class Iterable:
    def __init__(self, sequence):
        self.sequence = sequence

    def __iter__(self):
        return SequenceIterator(self.sequence)

for value in Iterable([1, 2, 3, 4]):
    print(value)  # 1 2 3 4 
```
<!-- @formatter:on -->

### Що таке `Iterator` у Python?

<hr>

**Iterator** — це об’єкт, який дає змогу по одному перебирати елементи послідовності в циклах та
інших виразах. Ключові характеристики:

* Має два методи:
    * `__iter__()` повертає сам iterator (`self`)
    * `__next__()` повертає наступний елемент або викликає `StopIteration`, якщо елементів більше
      немає.
* Iterator можна **отримати з будь-якого iterable** через функцію `iter()`.
* Після проходження всіх елементів iterator **вичерпується**.
* **Лінива (lazy) обробка**: iterator не створює всі елементи відразу, що економить пам’ять
  (особливо для генераторів чи великих послідовностей).

Ітератор відокремлює логіку зберігання даних від логіки їх обходу.

Загалом можна створити три різновиди ітераторів:

1. Ітератор, який приймає дані й повертає їх в тому вигляді, якому вони є.
    ```python
    class SequenceIterator:
        def __init__(self, sequence):
            self._sequence = sequence
            self._index = 0
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self._index < len(self._sequence):
                item = self._sequence[self._index]
                self._index += 1
                return item
            else:
                raise StopIteration

   for item in SequenceIterator([1, 2, 3, 4]):
        print(item) # 1 2 3 4
    ```
2. Ітератор, який приймає дані і повертає трансформовані елементи.

    ```python
    class SquareIterator:
        def __init__(self, sequence):
            self._sequence = sequence
            self._index = 0
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self._index < len(self._sequence):
                square = self._sequence[self._index] ** 2
                self._index += 1
                return square
            else:
                raise StopIteration
    
        for square in SquareIterator([1, 2, 3, 4, 5]):
            print(square)  # 1 4 9 16 25
    ```

3. Ітератор, який не приймає дані, а генерує й повертає нові.

    ```python
    class FibonacciIterator:
        def __init__(self, stop=10):
            self._stop = stop
            self._index = 0
            self._current = 0
            self._next = 1
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self._index < self._stop:
                self._index += 1
                number = self._current
                self._current, self._next = self._next, self._current + self._next
                return number
            else:
                raise StopIteration
    
    for fib_number in FibonacciIterator():
        print(fib_number)  # 0 1 1 2 3 5 8 13 21 34
    ```

### За що відповідає функція `next()` у Python?

<hr>

**Функція `next()`** у Python використовується для отримання наступного елемента ітератора. Вона
викликає метод `__next__()` у об’єкта-ітератора.

```python
next(iterator[, default])
```

* Якщо елемент доступний → повертає його.
* Якщо елементи закінчилися → викидає виняток `StopIteration`.

## Generators

### Що таке генератор у Python?

<hr>

**Генератор (generator)** — це спеціальний тип ітератора, який дозволяє отримувати значення "на
вимогу" замість того, щоб зберігати всю послідовність у пам’яті. Генератори створюються або за
допомогою функцій з ключовим словом `yield`, або за допомогою **генераторних виразів** (generator
expressions).
Ключові характеристики:

* **Ліниве обчислення:** значення обчислюються тільки тоді, коли вони потрібні, що економить
  пам’ять.
* Коли викликається `yield`, функція зупиняється і повертає значення, а при наступному виклику
  **продовжує з того ж місця**.
* **Ітератор:** генератор можна використовувати у циклах `for` або функціях, що приймають ітератори
  (`sum`, `list`, `next` і т.д.).
* Генератори особливо корисні для **великих обсягів** даних або **нескінченних послідовностей**.

<!-- @formatter:off -->
```python
def fibonacci_generator(stop=10):
    current_fib, next_fib = 0, 1
    for _ in range(0, stop):
        fib_number = current_fib
        current_fib, next_fib = next_fib, current_fib + next_fib
        yield fib_number

list(fibonacci_generator())  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
<!-- @formatter:on -->

Тут після завершення циклу, функція автоматично викличе `StopIteration`.

Для явного завершення, можна викликати `return` самостійно.

```python
def fibonacci_generator(stop=10):
    current_fib, next_fib = 0, 1
    index = 0
    while True:
        if index == stop:
            return
        index += 1
        fib_number = current_fib
        current_fib, next_fib = next_fib, current_fib + next_fib
        yield fib_number
```

### Iterator vs. Iterable vs. Generator

<hr>

**Iterable** — це об’єкт, що містить елементи, які можна перебрати в циклі `for` або
отримати через функцію `iter()`, що створює новий ітератор. Сам по собі iterable не “пам’ятає”, на
якому елементі зупинився.

* Реалізує метод `__iter__()`
* Приклади: `list`, `tuple`, `str`, `dict`, `set`

**Ітератор (iterator)** — це об’єкт, який представляє потік елементів, по яких можна пройтись один
раз. Він "пам’ятає" свій поточний стан під час ітерації. Коли елементи закінчуються, викликає
`StopIteration`.

* Реалізує методи `__iter__()` та `__next__()`

**Генератор (generator)** — це спеціальний тип ітератора, який створюється або за допомогою
функцій із `yield`, або через **генераторні вирази**. Генератори дозволяють отримувати значення
ліниво (lazy evaluation), тобто по одному, без завантаження всієї послідовності в пам’ять.

### Що таке генераторні вирази (generator expressions)?

<hr>

**Генераторні вирази (generator expressions)** - це скорочений спосіб створити генератор без
використання окремої функції з `yield`. Вони виглядають майже як спискові вирази (list
comprehensions), але замість квадратних дужок використовуються круглі.

```python
# Спискове включення – створює одразу список у пам’яті
squares_list = [x * x for x in range(5)]

# Генераторний вираз – створює генератор (ліниве обчислення)
squares_gen = (x * x for x in range(5))

print(squares_list)  # [0, 1, 4, 9, 16]
print(next(squares_gen))  # 0
print(next(squares_gen))  # 1
```

### Що таке `yield from` і як його використовують?

<hr>

`yield from` — це скорочений спосіб делегувати частину роботи іншому генератору або будь-якому
ітерабельному об’єкту. Замість того, щоб писати цикл із `yield` вручну, можна використати  
`yield from`.

<!-- @formatter:off -->
```python
def subgen():
    yield 1
    yield 2
    yield 3

def main():
    yield 0
    yield from subgen()  # делегує генератору subgen
    yield 4

print(list(main()))  # [0, 1, 2, 3, 4]
```
<!-- @formatter:on -->

Тут `main()` не пише цикл `for val in subgen(): yield val`, а просто використовує `yield from`.

### Чи можна перебирати елементи генератора кілька разів?

<hr>

**Ні.** Генератор можна обійти лише один раз, бо він "споживає" значення поступово. Якщо потрібні
повторні обходи, треба або зберігати дані в колекцію, або створювати новий генератор при кожній
ітерації.

<!-- @formatter:off -->
```python
def gen():
    yield 1
    yield 2
    yield 3

g = gen()

print(list(g))  # [1, 2, 3]
print(list(g))  # []

for _ in range(2):
    for val in gen():  # виклик gen() створює новий генератор
        print(val)  # [1, 2, 3]
```
<!-- @formatter:on -->

### Навіщо потрібні методи `send()`, `throw()` і `close()`?

* `send(value)` дозволяє надсилати значення всередину генератора в точку, де він зараз “завис” на
  `yield`. Зазвичай `yield` повертає значення назовні, але з `send()` він ще й приймає значення
  назад. Використовується у корутинах (до появи `async/await`).

    ```python
    def gen():
        x = yield "Початок"
        yield f"Отримав: {x}"
    
    g = gen()
    print(next(g))        # "Початок"
    print(g.send("Hello"))  # "Отримав: Hello"
    ```

* `throw(exc_type, exc_value=None, traceback=None)` дозволяє вкинути виняток у генератор у точку,
  де він зупинився на `yield`. Генератор може перехопити цей виняток через `try/except`. Якщо не
  перехопити → генератор завершується.

  ```python
  def gen():
      try:
          yield 1
      except ValueError:
          yield "Обробив ValueError"
  
  g = gen()
  print(next(g))  # 1
  print(g.throw(ValueError))  # "Обробив ValueError"
  ```

* `close()` викликає завершення генератора. Всередині викликається виняток `GeneratorExit`.
  Зручно для коректного завершення роботи (наприклад, закриття файлу або сесії).

  ```python
  def gen():
      try:
          yield 1
      finally:
          print("Генератор закрито")
  
  g = gen()
  print(next(g))  # 1
  g.close()  # "Генератор закрито"
  ```

## Context Managers

### Що таке контекстний менеджер у Python?

<hr>

**Контекстний менеджер (context manager)** — це об’єкт, який визначає середовище для виконання блоку
коду за допомогою конструкції `with`. Він відповідає за правильне відкриття та закриття ресурсів
(файли, сокети, з’єднання з БД тощо).

Є два основні способи реалізації свого контекстного менеджера — за допомогою класу або через
декоратор `@contextmanager` з модуля `contextlib`. Перший дає повний контроль, другий — більш
лаконічний для простих випадків.

Контекстний менеджер повинен реалізовувати два методи:

* `__enter__()` – викликається на початку блоку `with`. Повертає ресурс.
* `__exit__(exc_type, exc_value, traceback)` – викликається в кінці блоку, навіть якщо сталася
  помилка. Використовується для прибирання (закриття файлів, з’єднань і т.д.).

<!-- @formatter:off -->
```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("🔹 Входимо в контекст")
    yield "resource"  # тут виконується основна робота
    print("🔸 Виходимо з контексту")

with my_context() as res:
    print("Використовуємо:", res)
```
<!-- @formatter:on -->

### Навіщо потрібні контекстні менеджери?

<hr>

Контекстні менеджери у Python потрібні для **гарантованого управління ресурсами**. Вони
автоматизують відкриття/закриття, блокування/розблокування чи старт/фіналізацію операцій, щоб
уникати витоків пам’яті й помилок.

Основні задачі контекстних менеджерів:

1. Автоматичне **звільнення ресурсів** (файли (`open`), сокети, з’єднання з БД, мережеві запити).
2. Гарантоване **прибирання** навіть при помилках. Код у `__exit__` виконається завжди, навіть якщо
   в блоці `with` сталася виняткова ситуація.
3. Читабельність і чистота коду: замість `try/finally`, код у `with` виглядає лаконічно.

### Які стандартні приклади контекстних менеджерів є у Python?

<hr>

1. Робота з файлами: `open()`
    ```python
      with open("data.txt", "w") as f:
          f.write("hello")
    ```

2. Блокування (`threading.Lock`):
    ```python
    import threading
    
    lock = threading.Lock()
    with lock:
        # критична секція
        print("Робота з ресурсом")
    ```

3. Тимчасова зміна налаштувань точності обчислень `decimal.localcontext()`:
    ```python
    from decimal import Decimal, localcontext
    
    with localcontext() as ctx:
        ctx.prec = 4
        print(Decimal("1") / Decimal("7"))  # 0.1429
    ```

### Як обробляються винятки всередині блоку `with`?

<hr>

1. Коли виконується блок `with`, Python викликає метод `__enter__()` контекстного менеджера.
2. Потім виконується код всередині блоку `with`.
3. Якщо всередині блоку виникає виняток, Python не викидає його одразу.
4. Замість цього викликається метод `__exit__(exc_type, exc_value, traceback)`:
    * `exc_type` — тип винятку
    * `exc_value` — об’єкт винятку
    * `traceback` — трасування
5. Повертання значення з `__exit__`:
    * Якщо повертається `True`, виняток ігнорується і блок завершиться без помилки.
    * Якщо повертається `False` або нічого не повертається, виняток перекидається далі після
      завершення `__exit__`.

### Що таке витік пам'яті?

<hr>

**Витік пам’яті (memory leak)** — це ситуація, коли програма виділяє пам’ять, але не звільняє її,
навіть коли вона вже не потрібна.

Python має автоматне керування пам’яттю через GC (garbage collector) + лічильник посилань.
Тому класичні “витоки” (як у C) трапляються рідше, але можливі логічні витоки пам’яті: коли
об’єкти залишаються доступними через якісь посилання, і GC їх не може прибрати (незакриті ресурси,
нескінченні колекції, кругові посилання чи глобальні змінні).

### У чому різниця між 'try/finally' та контекстного менеджера ('with') у Python?

<hr>

`try/finally` і `with` вирішують схожу задачу — гарантоване звільнення ресурсів, навіть якщо під час
роботи виникають винятки. Але між ними є принципова різниця у стилі та зручності використання.

* `try/finally` — це базовий механізм, який дозволяє виконати cleanup-операції вручну.
    ```python
    f = open("data.txt", "w")
    try:
        f.write("hello")
    finally:
        f.close()
    ```

* `with` (контекстний менеджер) — це синтаксичний цукор поверх `try/finally`. Об’єкт, який
  використовується у `with`, реалізує протокол контексту (`__enter__`, `__exit__`), і Python
  самостійно виконує cleanup.
    ```python
    with open("data.txt", "w") as f:
        f.write("hello")
    ```

### Що таке асинхронний контекстний менеджер?

<hr>

**Асинхронний контекстний менеджер** — це об’єкт, який можна використовувати всередині async with.
Він реалізує асинхронний протокол контексту, тобто замість звичайних `__enter__` / `__exit__` має:

* `__aenter__(self)` — викликається при вході в блок `async with` (повинен бути `async def` або
  повертати `awaitable`).
* `__aexit__(self, exc_type, exc, tb)` — викликається при виході (теж асинхронний)

Асинхронні контекстні менеджери потрібні для керування асинхронними ресурсами, які потребують
await. Типові приклади: асинхронні HTTP-з’єднання (`aiohttp`), WebSocket-и, асинхронні блокування
(`asyncio.Lock`), транзакції у БД.

## Sequences та Mappings

### Що таке `Sequence` у Python?

<hr>

**Sequence (послідовність)** — це абстракція у Python для впорядкованих колекцій елементів, до яких
можна звертатися по індексу і які підтримують ітерацію.

Приклади вбудованих sequence:

* Змінні (mutable): `list`, `bytearray`
* Незмінні (immutable): `tuple`, `str`, `bytes`, `range`

Усі типи, що реалізують sequence protocol, мають:

* `__getitem__(self, index)` — доступ до елементів за індексом,
* `__len__(self)` — довжина.

Окрім цих двох методів, послідовності зазвичай реалізовують `__iter__()`.

Ключові властивості послідовностей:

* **Впорядкованість** — елементи зберігаються у певному порядку (на відміну від `set` чи `dict`).
* **Індексація** — можна звертатися до елементів за індексом `seq[i]`.
* **Слайси** — підтримують зрізи: `seq[start:end:step]`.
* **Ітерація** — можна пройтись циклом `for`.
* Операції:
    * Конкатенація: `"ab" + "cd"` → `abcd`
    * Повторення: `[1, 2] * 3` → `[1, 2, 1, 2, 1, 2]`
    * Перевірка належності: `x in seq`.
    * Лексикографічне порівняння значень: елементи йдуть зліва направо, і перша різниця визначає
      результат. Якщо всі елементи рівні, але довжини різні — коротша вважається меншою. Якщо всі
      елементи й довжина рівні — послідовності рівні.

### Для чого потрібен клас `collections.abc.Sequence`?

<hr>

У Python `collections.abc.Sequence` — це абстрактний базовий клас (ABC), який описує інтерфейс
послідовності.

Щоб клас вважався підкласом `Sequence`, достатньо реалізувати: `__getitem__(self, index)` і `__len__
(self)`.

І тоді він автоматично отримає від Sequence реалізації таких методів, як:

* `__contains__` (`in`)
* `__iter__`
* `__reversed__`
* `index()`
* `count()`

Навіщо потрібен?

1. Формальна перевірка типів
2. Стандартизація API

### Чим відрізняється `Sequence` від `MutableSequence` у Python?

<hr>

У Python `collections.abc.Sequence` — це абстрактний базовий клас (ABC), який описує інтерфейс
послідовностей для читання. Він вимагає реалізації лише двох методів: `__getitem__` і `__len__`.
Інші методи, такі як `__contains__`, `__iter__`, `count` та `index`, надаються автоматично.
Клас-нащадок, що наслідує `Sequence`, фактично є immutable з точки зору API: елементи можна
тільки читати, але стандартних методів для зміни (`append`, `pop`, `__setitem__`) він не має.

Щоб створити mutable послідовність, потрібно наслідуватися від `collections.abc.MutableSequence`.
Цей клас розширює `Sequence` і додає обов’язкові методи для модифікації: `__setitem__`,
`__delitem__`, `insert()`. Після їх реалізації ви автоматично отримуєте такі методи, як `append`,
`remove`, `pop` та `reverse`.

Таким чином, якщо мета — мати змінну послідовність, просто наслідування від `Sequence` недостатньо.
Необхідно використовувати `MutableSequence` і реалізувати базові методи для зміни елементів.

<!-- @formatter:off -->
```python
from collections.abc import MutableSequence

class MyList(MutableSequence):
    def __init__(self, data=None):
        self._data = list(data) if data else []

    def __getitem__(self, index):
        return self._data[index]

    def __setitem__(self, index, value):
        self._data[index] = value

    def __delitem__(self, index):
        del self._data[index]

    def __len__(self):
        return len(self._data)

    def insert(self, index, value):
        self._data.insert(index, value)

ml = MyList([1, 2, 3])
ml[0] = 10
ml.append(4)
print(list(ml))  # [10, 2, 3, 4]
```
<!-- @formatter:on -->

### Що таке `Mapping` у Python?

<hr>

**Mapping** — це асоціативна колекція, яка зберігає пари ключ → значення.

Ключові властивості мап:

1. **Доступ за ключем:** значення зберігаються не за позицією, а за ключем.
2. Кожен ключ у мапі повинен бути **унікальним**. Якщо додати ключ, що вже існує, його значення
   оновиться.
3. Раніше порядок ключів не гарантувався. Починаючи з Python 3.7, `dict` зберігає порядок вставки
   ключів.

Python надає `collections.abc.Mapping` — абстрактний базовий клас для всіх мап. Щоб вважатися
мапою, клас повинен реалізувати:

* `__getitem__(self, key)`
* `__iter__(self)` (ітерація по ключах)
* `__len__(self)`

Інші методи (`keys()`, `items()`, `values()`, `get()`) надаються автоматично.

### Чим відрізняється `Mapping` від `MutableMapping` у Python?

У Python `Mapping` і `MutableMapping` — це абстрактні базові класи (ABCs) для словникоподібних
об’єктів, але з різними рівнями доступу до даних.

`Mapping` — це immutable мапа, тобто інтерфейс лише для читання. Вимагає реалізації трьох базових
методів: `__getitem__(self, key)`, `__iter__(self)` і `__len__(self)`. Інші методи (`keys()`,
`items()`,
`values()`, `get()`) надаються автоматично. Підходить, коли потрібно, щоб колекція дозволяла тільки
доступ до даних, без змін.

`MutableMapping` — це mutable мапа, тобто мапа, де можна додавати, змінювати або видаляти елементи.
Окрім методів `Mapping`, потрібно реалізувати:

* `__setitem__(self, key, value)` — для додавання чи зміни елементів
* `__delitem__(self, key)` — для видалення елементів

Інші методи (`pop`, `update`, `clear`) надаються автоматично.
Використовується, коли потрібно створювати словникоподібні об’єкти з повною підтримкою модифікації.