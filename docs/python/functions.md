---
title: Функції
parent: Python
nav_order: 4
layout: default
---

<!-- @formatter:off -->
# Функції
- TOC
{:toc}
<!-- @formatter:on -->

## Загальне

### Що таке функція в Python?

<hr>

**Функція** — це блок коду, який виконує певне завдання і може бути використаний багаторазово.
Функції дозволяють структурувати програму, роблять код більш читабельним і зменшують дублювання
коду.

Оголошення функції відбувається за допомогою ключового слова `def`, наприклад:

<!-- @formatter:off -->
```python
def greet(name):
    return f"Hello, {name}!"
```
<!-- @formatter:on -->

### Параметр vs. аргумент

<hr>

**Параметр (parameter)** — це змінна, яка визначена у сигнатурі функції і слугує для прийому
значень. Параметри існують тільки під час оголошення функції.

<!-- @formatter:off -->
```python
def greet(name):  # name — це параметр
    return f"Hello, {name}!"
```
<!-- @formatter:on -->

**Аргумент (argument)** — це конкретне значення, яке передається функції під час її виклику.
Аргументи використовуються для ініціалізації параметрів.

```python
print(greet("Alice"))  # "Alice" — це аргумент
```

### Як передаються аргументи у функцію в Python?

<hr>

Аргументи в Python передаються за присвоєнням (**call by assignment**). Це означає, що У Python
передається посилання на об’єкт, але посилання саме по собі локальне всередині функції.

* Якщо аргумент — змінюваний об’єкт (mutable), наприклад `list` або `dict`, зміни всередині функції
  впливають на оригінальний об’єкт.
    <!-- @formatter:off -->
   ```python
   def add_item(lst, item):
       lst.append(item)
   
   my_list = [1, 2]
   add_item(my_list, 3)
   print(my_list)  # [1, 2, 3] — оригінальний список змінено
   ```
  <!-- @formatter:on -->

* Якщо аргумент — незмінюваний об’єкт (`immutable`), наприклад `int`, `str`, `tuple`, то операції
  всередині функції створюють новий об’єкт, і глобальний об’єкт не змінюється.

    <!-- @formatter:off -->
    ```python
    def increment(x):
        x += 1
        return x
    
    a = 10
    b = increment(a)
    print(a)  # 10 — оригінал не змінюється
    print(b)  # 11 — повернуте нове значення
    ```
    <!-- @formatter:on -->

### Які є різновиди параметрів у функціях?

<hr>

1. **Позиційні параметри (positional parameters)**: приймають значення відповідно до порядку при
   виклику.
   ```python
   def add(a, b):  # a, b — позиційні параметри
      return a + b
   ```

2. **Параметри за замовчуванням (default parameters)**: мають значення, яке використовується,
   якщо аргумент не передано.
   ```python
   def greet(name="Guest"):  # name — параметр за замовчуванням
       return f"Hello, {name}!"
   ```

3. **Параметри довільної кількості**
    * `*args` — позиційні параметри у вигляді кортежу.
    * `**kwargs` — іменовані параметри у вигляді словника.

   ```python
   def func(*args, **kwargs):
       print(args)    # кортеж позиційних аргументів
       print(kwargs)  # словник іменованих аргументів
   ```

### Як працюють `*args` і `**kwargs`?

<hr>

`*args` – довільна кількість позиційних аргументів

* Позначається зірочкою `*` перед назвою параметра (звичайно `args`).
* Всі передані позиційні аргументи збираються в кортеж (`tuple`).
* Використовується, коли невідомо, скільки аргументів буде передано.

   ```python
   def greet_all(*names):
       for name in names:
           print(f"Hello, {name}!")
   
   greet_all("Alice", "Bob", "Charlie")
   # Hello, Alice!
   # Hello, Bob!
   # Hello, Charlie!
   ```

`**kwargs` – довільна кількість іменованих аргументів

* Позначається двома зірочками `**` перед назвою параметра (звичайно `kwargs`).
* Всі передані іменовані аргументи збираються у словник (`dict`).
* Використовується, коли кількість або назви аргументів невідомі заздалегідь.

    <!-- @formatter:off -->
   ```python
   def print_info(**info):
       for key, value in info.items():
           print(f"{key}: {value}")
   
   print_info(name="Alice", age=25, city="Kyiv")
   # name: Alice
   # age: 25
   # city: Kyiv
   ```
  <!-- @formatter:on -->

В одній функції можна одночасно використовувати і `*args`, і `**kwargs`: позиційні аргументи
мають йти перед іменованими.

### Що таке обов'язкові та необов'язкові параметри/аргументи?

<hr>

**Обов’язкові аргументи (Required arguments)** – це аргументи, які повинні бути передані функції під
час виклику. Якщо їх не передати, Python видасть помилку `TypeError`. Зазвичай це позиційні
параметри без значення за замовчуванням.

<!-- @formatter:off -->
```python
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # Виведе: Hello, Alice!
greet()  # TypeError: missing 1 required positional argument: 'name'
```
<!-- @formatter:on -->

**Необов’язкові аргументи (Optional arguments)** – це аргументи, які можна не передавати. Вони мають
значення за замовчуванням.

<!-- @formatter:off -->
```python
def greet(name="Guest"):
    print(f"Hello, {name}!")

greet("Alice")  # Виведе: Hello, Alice!
greet()  # Виведе: Hello, Guest!
```
<!-- @formatter:on -->

### Порядок визначення параметрів функції

<hr>

1. **Обов’язкові позиційні параметри (positional required parameters)** зазначаються першими.

    ```python
    def func(a, b):
        pass
    ```

2. **Параметри за замовчуванням (default parameters)** йдуть після обов'язкових. Можуть бути
   пропущені
   під час виклику.

   ```python
   def func(a, b=10):
       pass
   ```

3. `*args` йдуть після обов’язкових і параметрів за замовчуванням.

   ```python
   def func(a, b=10, *args):
      pass
   ```

4. Тільки-іменовані параметри (keyword-only parameters) йдуть після `*args` і можуть передаватися
   лише іменованими аргументами. Можуть мати або не мати значення за замовчуванням.

   ```python
   def func(a, b=10, *args, c, d=20):
       pass
   ```

5. `**kwargs` збирає всі додаткові іменовані аргументи у словник. Завжди останні у сигнатурі
   функції.

   ```python
   def func(a, b=10, *args, c, d=20, **kwargs):
       pass
   ```

Отже, порядок визначення параметрів у функції:

```python
(обов’язкові, необов’язкові, * args, лише-за-ключем, ** kwargs)
```

### Навіщо використовуються оператори `/` та `*` у списку параметрів?

<hr>

**Forward slash `/`** — тільки-позиційні параметри. Параметри, які стоять ліворуч від `/`, можна
передавати тільки позиційно. Їх не можна передавати як іменовані аргументи.

<!-- @formatter:off -->
```python
def func(a, b, /, c, d):
    print(a, b, c, d)

func(1, 2, c=3, d=4)  # Правильно
func(a=1, b=2, c=3, d=4)  # TypeError
```
<!-- @formatter:on -->

**Asterisk `*`** — тільки-за-ключем (keyword-only) параметри. Параметри, які стоять після `*`, можна
передавати тільки іменованими аргументами. Їх не можна передавати позиційно.

<!-- @formatter:off -->
```python
def func(a, b, *, c, d=10):
    print(a, b, c, d)

func(1, 2, c=3, d=4)  # Правильно
func(1, 2, 3, 4)  # TypeError
```
<!-- @formatter:on -->

Можна комбінувати для повного контролю:

<!-- @formatter:off -->
```python
def func(a, b, /, c, d=10, *, e, f=20):
    print(a, b, c, d, e, f)

func(1, 2, 3, d=4, e=5, f=6)  # Правильно
```
<!-- @formatter:on -->

* `a, b` — тільки позиційно
* `c, d` — можуть бути передані позиційно або за ключем
* `e, f` — тільки за ключем

### Параметри за замовчуванням для змінних типів

<hr>

В Python значення параметрів за замовчуванням обчислюється лише один раз, під час визначення
функції (виконання `def`), а не при кожному виклику. Якщо параметр — mutable об’єкт (наприклад,
`list`, `dict`, `set`), всі виклики функції будуть використовувати один і той же об’єкт.

Приклад проблеми:

<!-- @formatter:off -->
```python
def add_item(item, my_list=[]):
    my_list.append(item)
    return my_list

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] — неочікувано!
print(add_item(3))  # [1, 2, 3]
```
<!-- @formatter:on -->

Рішення: використовувати `None` як значення за замовчуванням і створювати новий об’єкт усередині
функції.

<!-- @formatter:off -->
```python
def add_item(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list

print(add_item(1))  # [1]
print(add_item(2))  # [2]
print(add_item(3))  # [3]
```
<!-- @formatter:on -->

## Вкладені функції, lambda-функції та замикання

### Що таке вкладена (inner) функція?

<hr>

**Вкладена функція (inner function)** — це функція, яка оголошується всередині іншої функції.
Такі функції існують лише всередині зовнішньої функції і недоступні зовні.

Вкладені функції використовується для:

* Інкапсуляції логіки, яка не потрібна зовні.
* Створення замикань (closures).
* Підвищення читабельності та організації коду.

<!-- @formatter:off -->
```python
def outer_function(x):
    def inner_function(y):
        return y * 2  # логіка, доступна лише всередині outer_function
    result = inner_function(x) + 5
    return result

print(outer_function(10))  # Виведе: 25
# print(inner_function(10))  # Error! inner_function недоступна зовні
```
<!-- @formatter:on -->

Вкладена функція може запам’ятовувати  (замикати) значення зовнішніх змінних навіть після
завершення виконання зовнішньої функції:

<!-- @formatter:off -->
```python
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```
<!-- @formatter:on -->

Тут `multiplier` пам’ятає значення n із зовнішньої функції.

### Що таке замикання (closure)?

**Замикання (closure)** — це функція, яка запам’ятовує значення змінних зі свого оточення (
зовнішньої
функції) навіть після того, як зовнішня функція завершила виконання. Замикання утворюється, коли:

* Є вкладена функція.
* Внутрішня функція звертається до змінних зовнішньої функції.
* Зовнішня функція повертає внутрішню функцію.

Замикання дозволяє зберігати стан функції без використання глобальних змінних.

<!-- @formatter:off -->
```python
def make_multiplier(n):
    def multiplier(x):
        return x * n  # звертаємося до змінної зовнішньої функції
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```
<!-- @formatter:on -->

Після виклику `double = make_multiplier(2)` змінна `n=2` «замикається» всередині `double`. Тобто
`multiplier` пам’ятає значення `n`, навіть коли `make_multiplier` завершила виконання.

### Що таке `lambda`-функція?

<hr>

**Lambda-функція** — це анонімна функція. Використовується для коротких функцій, які виконують
просту операцію. Lambda-функція може містити тільки один вираз, який повертає значення
автоматично (без `return`).

Синтаксис: `lambda аргументи: вираз`

Приклади:

1. Проста функція, яка додає два числа
   ```python
   add = lambda x, y: x + y
   print(add(3, 5))  # 8
   ```

2. Сортування списку словників за ключем
   ```python
   people = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 20}]
   people.sort(key=lambda person: person['age'])
   print(people)
   # [{'name': 'Bob', 'age': 20}, {'name': 'Alice', 'age': 25}]
   ```

3. Використання з функціями `map`, `filter`, `reduce`
   ```python
   nums = [1, 2, 3, 4, 5]
   squared = list(map(lambda x: x ** 2, nums))
   print(squared)  # [1, 4, 9, 16, 25]
   ```

### Чи можна створити замикання за допомогою lambda?

<hr>

Lambda-функції, як і звичайні функції, можуть бути вкладеними і звертатися до змінних зовнішньої
функції. Це дозволяє створити замикання, де lambda «запам’ятовує» значення параметрів зовнішньої
функції.

<!-- @formatter:off -->
```python
def make_multiplier(n):
    return lambda x: x * n  # lambda звертається до зовнішньої змінної n

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```
<!-- @formatter:on -->

### Які підводні камені при використанні замикань у циклах?

В Python вкладена функція або `lambda` запам’ятовує посилання на змінну, а не її значення на момент
створення функції. Якщо змінна змінюється у циклі, всі замикання «бачать» останнє значення змінної.

Приклад проблеми:

```python
funcs = []

for i in range(3):
    funcs.append(lambda: i)

for f in funcs:
    print(f())
```

Очікуваний результат: 0, 1, 2, реальний результат: 2, 2, 2.

Чому? Lambda замкнула посилання на `i`, а не його значення під час кожної ітерації. Коли цикл
закінчився, `i = 2`, і всі lambda-функції повертають `2`.

Рішення: передати поточне значення змінної як аргумент за замовчуванням у `lambda` або вкладену
функцію.

```python
funcs = []

for i in range(3):
    funcs.append(lambda i=i: i)  # i=i «захоплює» поточне значення

for f in funcs:
    print(f())
# Виведе: 0, 1, 2
```

Тут `i=i` створює локальне значення аргументу, яке `lambda` «запам’ятовує».

## Scopes

### Що таке область видимості (scope)?

<hr>

`Область видимості (scope)` — це частина програми, де змінна або ім’я (функції, класу) доступні для
читання або зміни. В Python область видимості визначає, де змінна існує і як її можна
використовувати.

Є два основні типи змінних:

* **Локальні (local)** — оголошені всередині функції або блоку, видимі лише там.
* **Глобальні (global)** — оголошені на верхньому рівні файлу, видимі у всій програмі (за винятком
  перекриття локальними).

### Порядок розв'язання імен у Python (LEGB)

<hr>

Python використовує правило **LEGB**, яке визначає порядок пошуку змінної:

1. Local — локальна: змінні всередині функції
2. Enclosing — зовнішня функція: змінні зовнішньої функції для вкладених функцій (`nonlocal`)
3. Global — глобальна: змінні на рівні модуля (`global`)
4. Built-in — вбудовані: функції та константи Python (`len`, `int`)

Локальна область видимості:

<!-- @formatter:off -->
```python
def func():
    x = 10  # локальна змінна
    print(x)

func()
# print(x)  # Error: x не визначена поза функцією
```
<!-- @formatter:on -->

Глобальна область видимості:

<!-- @formatter:off -->
```python
y = 5  # глобальна змінна

def func():
    print(y)  # доступна глобальна змінна

func()  # 5
```
<!-- @formatter:on -->

Nonlocal / Enclosing:

<!-- @formatter:off -->
```python
def outer():
    x = 10
    def inner():
        nonlocal x
        x += 5
    inner()
    print(x)  # 15

outer()
```
<!-- @formatter:on -->

### Навіщо потрібно ключові слова `global` та `nonlocal`?

<hr>

Ключове слово `global` дозволяє змінювати змінні, оголошені на глобальному рівні, всередині функції.
Без `global` при присвоєнні всередині функції створюється локальна змінна, навіть якщо глобальна
існує.

<!-- @formatter:off -->
```python
x = 10  # глобальна змінна

def modify_global():
    global x
    x += 5  # змінюємо глобальну змінну

modify_global()
print(x)  # 15
```
<!-- @formatter:on -->

Ключове слово `nonlocal` дозволяє змінювати змінну у зовнішній функції (не глобальній).
Використовується у вкладених функціях для замикань.

<!-- @formatter:off -->
```python
def outer():
    x = 5  # локальна змінна зовнішньої функції
    def inner():
        nonlocal x
        x += 10  # змінюємо змінну зовнішньої функції
    inner()
    print(x)

outer()  # 15
```
<!-- @formatter:on -->

## Decorators

### Що таке декоратор у Python?

<hr>

**Декоратор (decorator)** — це функція, яка приймає іншу функцію як аргумент і повертає нову функцію
або модифіковану версію оригінальної. Використовується для розширення або модифікації поведінки
функцій чи методів без зміни їх коду.

Декоратори часто застосовуються для: логування, перевірки прав доступу, кешування результатів,
замірювання часу виконання функції.

```python
@decorator_name
def my_function():
    ...
```

Це еквівалентно:

<!-- @formatter:off -->
```python
def my_function():
    ...

my_function = decorator_name(my_function)
```
<!-- @formatter:on -->

**Приклад простого декоратора**

<!-- @formatter:off -->
```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("До виклику функції")
        result = func(*args, **kwargs)
        print("Після виклику функції")
        return result
    return wrapper

@decorator
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
```
<!-- @formatter:on -->

### Як визначити декоратор з аргументами?

<hr>

Якщо декоратор сам повинен приймати аргументи, потрібна третя функція, яка повертає власне
декоратор. Тобто три рівні вкладення:

1. Функція-декоратор з аргументами
2. Справжній декоратор, який приймає функцію
3. Wrapper, який обгортає виклик оригінальної функції

Тобто використовується фабрика декораторів (функція, що повертає декоратор), щоб надати аргументи
для налаштування.

Синтаксис:

<!-- @formatter:off -->
```python
def decorator_with_args(decorator_arg):
    def actual_decorator(func):
        def wrapper(*args, **kwargs):
            print(f"Декоратор отримав аргумент: {decorator_arg}")
            return func(*args, **kwargs)
        return wrapper
    return actual_decorator

@decorator_with_args("Hello!")
def greet(name):
    print(f"Hi, {name}")

greet("Alice")
```
<!-- @formatter:on -->

### Який порядок застосування декораторів?

<hr>

Якщо на одну функцію накладено кілька декораторів, вони застосовуються знизу вгору, тобто спочатку
виконується декоратор, який ближче до функції. Виглядає як стек обгорток: нижчий декоратор
обгортає функцію, а верхній декоратор обгортає вже результат нижнього.

```python
@decorator1
@decorator2
def func():
    print("Original function")
```

Це еквівалентно:

```python
func = decorator1(decorator2(func))
```

### Для чого використовувати `functools.wraps`?

<hr>

Коли ми пишемо свій декоратор, він зазвичай повертає внутрішню функцію-обгортку (wrapper).
Через це оригінальна функція втрачає свої метадані:

* `__name__` (ім’я функції),
* `__doc__` (docstring),
* інші атрибути (наприклад, анотації параметрів).

Приклад без `wraps`:

<!-- @formatter:off -->
```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Функція вітає користувача"""
    print(f"Hello, {name}!")

print(greet.__name__)  # wrapper ❌
print(greet.__doc__)  # None ❌
```
<!-- @formatter:on -->

`functools.wraps` — це декоратор для декораторів, який копіює метадані оригінальної функції до
`wrapper`.

<!-- @formatter:off -->
```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Функція вітає користувача"""
    print(f"Hello, {name}!")

print(greet.__name__)  # greet ✅
print(greet.__doc__)  # Функція вітає користувача ✅
```
<!-- @formatter:on -->

## Рекурсія

### Що таке рекурсія?

<hr>

**Рекурсія (recursion)** — це техніка програмування, коли функція викликає саму себе для розв’язання
задачі, яка може бути розбита на підзадачі того ж типу.

Ключові елементи рекурсії

* База рекурсії (base case) — умова, яка зупиняє рекурсію.
* Рекурсивний виклик — виклик функцією самої себе з "меншою" або "простішою" задачею.

Без бази рекурсія буде нескінченною і призведе до помилки переповнення стеку (`RecursionError` у
Python).

```python
def factorial(n):
    if n == 0:  # база рекурсії
        return 1
    return n * factorial(n - 1)  # рекурсивний виклик
```

Переваги рекурсії

* Лаконічний і зрозумілий код для задач із природною рекурсивною структурою: дерева, графи,
  математичні обчислення (факторіал, Фібоначчі), алгоритми пошуку та сортування (quicksort,
  mergesort).

Недоліки рекурсії

* Більше використання пам’яті (кожен виклик зберігається у стеку).
* У Python є обмеження на глибину рекурсії (`sys.getrecursionlimit()`, за замовчуванням ≈1000).
* Іноді ітеративне рішення ефективніше.

### Чи завжди можна рекурсивний виклик замінити циклом?

<hr>

Так, Теоретично будь-яку рекурсію можна замінити циклом. Усе, що виконує рекурсія через стек
викликів функцій, можна реалізувати вручну через явний цикл + власний стек (або іншу структуру
даних).
